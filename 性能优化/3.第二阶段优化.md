# 我在有赞做小程序性能优化
经过22年下半年的优化，点单宝点单页首开进入了4s，比之前有了很大提升，但实际上还是很慢。23年年前TL找我谈了话，大概意思就是年后又要开始第二轮性能优化，点单宝点单页面首开目标是2s，由我来own这个事。

## 现状
经过第一轮性能优化，基础性质的优化都已经完成，我们面临的情况依旧是经验不足，不知道还有哪些点可以优化，怎么去发掘新的优化点。第二轮性能优化我变成owner后，TL协调配了一个小团队——由3个前端、2个后端、1个测试组成，我们一起想办法完成2s的优化目标。

## 数据埋点
做再多优化，如果没有精确的数据支撑，都是无意义的。

我们在第二阶段性能优化初期先采用了本地log的方式手动跑数据，基于数据绘制了首开流程图，其中包含完整的首开链路和每个链路的耗时了，然后优先优化最长耗时链路。

上线前，我们对关键路径都上报了埋点日志，包括完整链路、配置接口、商品接口、商品渲染等路径等耗时，加上有赞商家基数，每周都有大量数据，通过对长耗时链路/日志的分析，再做精细化改造。

## 配置接口前置
小程序自身以包的概念存在，用户想使用一个小程序就需要先更新好主包，加上配置分包预加载的规则，对比H5我们可以认为小程序的资源请求成本接近0（当然小程序目前也无法做到SSR，和H5对比各有千秋），同时小程序共享唯一**APP实例**（可通过`getApp()`获取到）。

在第一轮优化中我们合并了一个首开配置接口，这个接口的耗时大约是200ms+，而小程序分包跳转耗时大约是120ms，当用户在首页点击时，我们先请求配置接口，存在全局实例上，再发起点单页跳转，利用分包跳转的这段时间去预请求配置接口，这样到点单页，只需要再等待几十ms，就可以拿到请求结果。

## 商品列表的重构——实现一版高性能虚拟列表
商品列表是整个点单页的重中之重，且有赞是做SASS的，我们的商品列表要支持的功能就非常非常多。

最初的渲染模式是用户切换到某个分组，去请求这个分组下所有商品数据并一次性渲染。

这种模式有几个缺点：
* 增量式渲染，我们有些商家有大几百个商品甚至上千商品，卡顿感明显
* 首屏可能只展示6个商品，但是整个分组内的商品都会渲染

加上当时产品提了一个商品列表支持二级分组的需求，以此为契机我重构了一版商品列表。

商品列表的优化在重构完持续到这篇文章诞生，中间只要我们想到可以优化商品列表的举措就会技术排期来开发，至今这个商品列表代码已经非常复杂。

后面我会另起一篇文章详写商品列表的实现思路和优化思路。

## 商品列表接口优化
第一阶段优化中我们把商品列表接口链路做了聚合，但聚合后的请求时间依旧要1.2s，我们如果要完成2s的首开目标，那么商品列表接口请求时间就要控制到400ms左右。这方面我们和后端做了大量沟通，确实面临很大的困难——我们业务复用的中台的商品模型，后端是对中台接口做了一层封装，加上我们自己业务需要的数据提供给前端，如果接口层面要做优化，得中台后端团队想办法，中间还有一些扯皮的事。

当然最终我们还是靠自己，解决了商品列表接口耗时长的问题。一次请求的耗时，可以分为几个阶段
1. 浏览器请求队列等待
2. HTTP传输——发送请求
3. Node请求Dobbo服务
4. Node处理数据
5. HTTP传输——返回请求

其中1、2业务方无法做太多优化，那么就是在3、4、5上想办法：

### 过滤冗余字段

一个HTTP响应数据的大小对传输时间是有影响的，而碰到商品列表一个分组下动则好几十个商品时，传输时间随数据大小变大而巨增（假设未开启gzip压缩）。

我们在Node层把商品数据做了过滤，只返回必要数据。测试开启gzip压缩的前提下，商品列表接口单次请求能减少50ms左右耗时。

### 接口数据动静分离
在有赞，一次请求链路内涉及的每个服务都会上报日志，并且在请求的响应头内返回一个自定义响应头`x-trace-id`。技术可以通过这个traceId在日志平台完整得查看一个请求在服务器执行的所有服务和每次服务的耗时。

我们通过分析商品列表完整请求链路发现单个商品数据的查询大致可以分为两部分：
* 商品的基本信息：包括商品的标题、图片、描述等
* 商品的活动信息：主要包括商品参与的营销活动和价格

商品的基本信息查询很快，线上90RT平均耗时在200ms内。而商品的活动信息则跟商家在后台配置的营销活动数量正相关——有赞作为SASS服务商，提供了市面上几乎所有得营销工具（包括优惠券、凑单、满减、打包一口价等等），单个商品的最终活动信息需要把商家开启的所有营销活动数据拿到，再依次执行每个活动对应的方法，最终才可以得到这个商品最优惠的活动信息和价格，那么商家配置的营销活动越多，商品的活动信息查询就越慢。

那么在后端没法对商品活动信息部分做有效优化的前提下，我提出了商品接口动静分离———商品接口一拆为二：静态数据接口与动态数据接口。客户端先请求静态数据接口，拿到返回结果后渲染商品基础信息，渲染完毕后请求动态数据接口，延迟展示商品活动信息与价格。

这样做的好处是：
* 渐进式渲染

分离后商品的渲染逻辑变为了，先渲染标题、图片、描述等信息，而价格部分则是一个小骨架状态，等约500ms，价格展示出来。从用户视角看，一个商品首先是图片和名称让用户感兴趣，才会去看价格是否合适（包含优惠力度）。那么我们对接口拆分，修改客户端渲染逻辑，正好符合了渐进式渲染，同时也不会让用户长时间只能看到商品骨架。

* 静态数据缓存

商品的基本信息通常是不会变的（商家不会频繁去改商品基本信息），或者说是静态数据。考虑到这部分数据的不变性，我们为其加上缓存，如果命中缓存，接口耗时可以缩短到100ms左右（整个HTTP请求响应时间约200ms）。

* 动态数据服务端提前处理

商品的动态数据部分耗时依旧很长（与商家配置的活动数量正相关），页面商品列表基本信息渲染很快，但是价格部分要等较长时间才渲染完。考虑到我们把商品的渲染逻辑改为了先请求静态数据，渲染完成后再请求动态数据，这中间存在几百毫秒时间间隔，并且如果请求了静态数据，那么必然后续会请求动态数据。基于这两个前提，后端服务在返回商品基本信息集合后，就会先处理对应商品集的动态数据，当客户端请求动态数据接口时，服务端会等之前处理的动态数据服务完成后把动态数据集返回给客户端。这样动态数据接口耗时也大幅缩短，当用户看到商品基本信息展示后，等待约500ms，活动信息就会展示。

## 首开链路调整
最初，点单宝首开链路按照业务流程是：
1. 初始化：获取配置接口数据
2. 进店：获取店铺信息、支持配送方式，最终确定当前用户配送方式
3. 获取分组：获取商品分组信息
4. 获取商品：获取第一个分组商品列表信息

这四点依次串行执行。

我们重点分析这个流程后做了两点优化，一是商品分组请求后端链路线上90RT耗时约200ms，并且入参只依赖店铺ID，这个请求可以直接合并到初始化接口中并行发起，并且最初始化接口性能影响不大；二是如果用户是点击自提进入，那么实际不依赖进店数据，我们在初始化结束获取到商品分组数据后，就立即以默认自提配送的参数（绕过进店）请求第一个商品分组接口，如果后续进店判断用户是外送，那么就丢弃这个请求的结果。这两点改动让首开快了约300ms。

## 基建优化——升级至HTTP2
中台统一将HTTP协议升级至HTTP2，HTTP2的优点（对小程序场景而言）是：
* 头部压缩：让请求传输数据更小
* 多路复用：解决应用层的队头阻塞、慢启动等问题

由于HTTP2基于TCP协议来传输数据，所以在传输层依旧存在队头阻塞，那么减小数据传输体积、解决慢启动等问题实际能优化的收益有限，当时预估升级对每个请求带来的收益约15ms。

## 初识框架
### 小程序
微信小程序官方在用户体验上可以说下足了功夫（也要吐槽一下对开发者的限制越来越多），例如小程序包的升级更新会在后台空闲时间静默执行、热启动会从本地读取小程序基本信息、冷启动仅先从微信后台获取主包和必要分包。

同时，官方也会开发者配备了[性能与体验相关文档](https://developers.weixin.qq.com/miniprogram/dev/framework/performance/)。

广义上看，小程序性能主要分为**启动性能**和**运行时性能**。

我们团队负责优化的点单宝点单页，属于在分包内的二级页，由于有预加载规则的存在，启动性能中最重要的代码包体积的问题可以忽略（实际上经过压缩我们的分包体积并不是很大，同时代码包体积减少百k以内对启动的影响不会很大）。

对于运行时性能，因为同样因为点单宝点单页是二级页，所以可以接口前置。其次重点就是对**setData**的合理使用。

官方对setData流程的说明：
1. 逻辑层虚拟DOM树的遍历和更新，触发组件生命周期和observer等
2. 将data从逻辑层传输到视图层
3. 视图层虚拟DOM树的更新、真实DOM元素的更新并触发页面渲染更新

由于小程序双线程的架构，渲染层和逻辑层无法直接共享数据，需要进行数据序列化、跨线程通信、数据反序列化，所以setData是实际是一个**半同步半异步**的API。对于逻辑层虚拟DOM树解析到对data数据的序列化并推入消息队列这个过程是同步的，后续数据传输、反序列化、视图层更新页面这个过程是异步的。

同样因为小程序双线程的架构，setData异步阶段流程不会阻塞逻辑层脚本代码的执行，但是同步阶段尤其是数据序列化会因为data数据的大小而受到明显影响，且这一步会阻塞逻辑层执行。

所以在小程序优化中，控制setData的频率以及setData数据的大小就非常重要。

### Tee框架
Tee是一个类Vue2语法的半编译半运行时框架。

单个小程序页面/组件需要的js文件实质就是导出一个配置对象Option，那么天然就支持封装。

#### 编译阶段
在编译阶段，Vue的template会单独编译为wxml；script部分本身就是导出一个Option，这个Option在Tee内被称为RuntimeCode（根据类型细分为PageRuntimeCode和ComponentRuntimeCode，PageRuntimeCode比ComponentRuntimeCode多onShow和onHide两个配置项），RuntimeCode会作为参数注入到Tee封装的（对应平台的）构造器中供运行时使用；style部分会单独编译为wxss。

#### 运行阶段
##### 构造函数
###### H5
在H5上就是个完整的Vue2，因为Tee的语法本身就和Vue高度类似，所以构造函数也很简单，类似：
  ```javascript
    // Page Constructor
    // H5都是单页应用，所以只需要PageConstructor内`new Vue()`
    export function Page(code: PageCode) {
      return new Vue(code);
    }

    // Component Constructor
    export function (code: ComponentCode) {
      return code;
    }
  ```

而入参code就是编译阶段提到的RuntimeCode。

###### 小程序
在小程序上构造函数相对复杂点。完整的Vue特性、原生事件、方法和生命周期函数都要在其中做好融合。

为此Tee实现了两个构造函数Vm和Actuator，Vm负责实现完整的Vue特性，而Actuator负责实现生命周期和初始化相关。

* Vm：完整的Vue特性都在Vm构造函数内封装提供
  ```javascript
    // Vm.js
    import { set, del } from 'observer';
    import { native } from 'native-instance';

    let id = 0;
    export class Vm {
      props = {};
      data = {};
      $events = {};
      _watcher;
      $id = id + 1;
    
      $set(target, key, val) {
        return set(this, target, key, val);
      }
      $delete(target, key) {
        return del(target, key);
      }

      $on(event, fn) {}
      $once(event, fn) {}
      $off(event, fn) {}
      $emit(event, ...args) {}

      _nativeCreated() {
        // 在小程序生命周期beforeCreate内执行
        // 将原生小程序原生实例上的一些属性和方法绑定到Vm实例上，例如
        // 例如renderWatcher执行批量异步更新时，就需要调用原生setData方法
        Object.defineProperty(this, 'setData', {
          get: native.setData,
          configurable: true,
        });
      }

      $watch() {
        // computedWatcher & userWatcher here
      }

      $forceUpdate() {
        if (this._watcher) this._watcher.update();
      }

      $nextTick(cb) {
        // 判断是否存在renderWatcher
        // 有就统一收集cb，最终在原生setData的回调中依次执行
        // 没有就推入微任务队列中等待执行
      }

      $destroy() {
        // 在小程序生命周期destroyed内执行
        // 主要把存储在内存中的一些数据释放，比如销毁watcher和dep的双向依赖收集
      }
    }
  ```

* Actuator：实现生命周期函数和响应式数据初始化。上层原生小程序对应生命周期执行时，就会执行对应Actuator实例内的生命周期方法
  ```javascript
    import { Vm } from 'Vm';

    export default class Actuator {
      vm;
      _runtime;
      $children = [];
      $parent;

      constructor(runtimeCode) {
        this._runtime = runtimeCode;
        this.vm = new Vm();
      }

      beforeCreateInvoke() {
        this.vm._nativeCreated();
      }

      create() {
        // 初始化响应式数据和renderWatcher
        // 流程上和Vue非常相似
        const { vm } = this;
        // 将RuntimeCode上的属性绑定到Vm实例上
        // 响应式数据做好响应式处理，这部分代码和Vue几乎一致
        initInjections(this, this._runtime.inject);
        initProps(this, this._runtime.props);
        initData(vm, this._runtime.data);
        initComputed(vm, this._runtime.computed);
        initWatch(vm, this._runtime.watch);
        // 初始化renderWatcher
        initRender(
          this,
          Object.keys(vm.data)
            .concat(Object.keys(vm.props))
            .concat(Object.keys(vm._computedWatchers || {})),
          Object.keys(vm._computedWatchers || {}),
        );
        initProvide(vm, this._runtime.provide);
      }

      mounted() {
        this.vm.$forceUpdate();
      }

      destroyed() {
        this.vm.$destroy();
      }
    }
  ```

##### 渲染
###### H5
在H5上就是个完整的Vue2，响应式数据变更后将renderWatcher推入微任务队列，后续生成虚拟DOM，在patch阶段比对变更真实DOM。

###### 小程序
原生小程序渲染依赖setData方法，那么框架内部最终肯定也是将变更的data传入setData中，后续靠小程序自身去处理。这部分的**核心代码都在上文Actuator构造函数内的initRender方法中**。

Actuator构造函数内的initRender方法作用和Vue2中的mountComponent作用是一样的，都是为组件实例绑定renderWatcher。
  ```javascript
    import { Watcher } from 'observer';
    import { renderFlushCallbacks } from 'next-tick';

    export function initRender(
      actuator,
      keys,
      computedKeys
    ) {
      const { vm } = actuator;

      function renderWatcher() {
        if (!vm._init) {
          // 手动把所有响应式数据都执行一下，触发依赖收集
          // 这里和Vue不同的是
          // Vue的Watcher每次执行后都会清理依赖收集
          // 而Tee的RenderWatcher只会在页面销毁时清理依赖收集
          Object.keys(keys).forEach((key) => walk(vm[key]));
        }
        // 比对出变更的响应式数据
        // Tee内比对变更数据采用的策略不是diff，这里这么写只是为了好理解
        // 实际上Tee采用了脏数据检查机制，数据变更记录在vm.$dirty内
        // 在响应式数据触发setter时，检查当前数据是否变更
        // 如果数据变更，则先将当前数据在$dirty收集到的所有子节点path全部清除
        // 再将当前数据的path记录到$dirty内
        const diffData = diff(vm);
        vm.setData(diffData, {
          cb: renderFlushCallbacks // 在setData的回调中执行$nextTick中定义的回调
        });
        vm._init = true;
      }
      return new Watcher(vm, renderWatcher, noop, null, true)
    }
  ```

核心代码renderWatcher主要就是做两件事：
* 触发依赖收集
  
  小程序是有虚拟DOM的，并且在逻辑层和渲染层都各自维护了虚拟DOM，但是让小程序支持Vue特性是开发者引入的，且开发者无法感知到小程序DOM的存在。换而言之，类似Vue在批量异步更新阶段，执行render函数生成虚拟DOM时**按需触发依赖收集**这种方式，在小程序运行时是无法复刻的，所以Tee选择renderWatcher初始化阶段全量触发组件内所有响应式数据的依赖收集（后续只有在组件销毁时，才会清除这些依赖收集关系，这点也和Vue不同）。

  这样做解决了小程序无法通过虚拟DOM按需依赖收集的问题，但问题很明显：某个响应式数据发生变化，这个数据对应的Dep会通知所有收集到的Watcher更新，无论这些Watcher对应的页面渲染是否需要这个数据，也就是说如果开发不清楚框架原理，使用不当，会导致setData的数据量变多，非常影响性能（这也是对第一阶段优化中提到的我们大量使用computed属性为什么是一个负优化的解答）。

* 对发生变化的数据执行setData

  原生开发中所有setData的数据都由开发把控，但是在Tee中，开发只有通过变更响应式数据来达到触发setData的目的。当某个响应数据变更触发setter方法时，Tee会收集变数据的详细路径（类似`[{ path: 'a.b.c', value: '1' }]`，如果这个path已经存在则会被覆盖），再通过Dep通知所有收集到的Watcher更新。最终当RenderWatcher执行更新时，将所有收集的发生变更的数据统一执行setData。

  也就是说虽然Tee无法感知到某个响应式数据是否参与渲染，但是还是做到了尽可能最小粒度setData（Tee只对变更的数据执行setData，若要控制data只包含渲染相关数据，就得看开发对框架的熟悉程度了）。

## 总结
在第二阶段，我们意识到了数据的重要性，通过收集生产数据来论证优化效果以及寻找当前耗时最长链路。

在服务端，我们最大的创新是将商品列表接口动静分离，用户视角看商品基本信息展示很快，大约过500ms价格也展示出来，很契合渐进式渲染，大幅减少商品列表白屏时间，提升了用户体验。我们也将商品分组聚合到前置配置接口集合中。服务端的优化可以对所有设备都有效果。

在客户端，我们实现了一个很贴合我们业务场景的高性能虚拟列表，商品数在1000以内滑动很流畅。同时，我们重新整理了首开流程，并且针对性的改动，让自提进入点单页这个场景的首开更快。客户端的优化对性能较差的设备效果越好。

我们也初步探索了小程序架构和多端框架Tee的源码，基于对Tee的运行时的理解，做了一些措施，例如将很多渲染无关的computed属性改为手动调用方法来执行，来尽可能保证小程序setData的数据只与渲染有关。

最终，我们成功的将点单宝点单页首开优化到2s内（性能好的设备，例如iPhone13，可以到1s内）。

