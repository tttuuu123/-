# 设计模式
**************************

## 引言
- 我把往期大哥们的分享都看过，我不知道大家有没有注意到一个问题：
	大哥们的分享涉及到了好几个设计模式，但是我们平时用到的好像只有策略模式，主要还是用来消除过多的`if else`嵌套。

## 为什么要会设计模式
- 这个问题我觉得可以和**`为什么我们要会数据结构`**放一起回答。
	数据结构教我们如何写高效的代码，设计模式教我们如何写高质量的代码。
- 在我们的日常中，大多数情况都是将业务翻译成代码。所以很多时候我们下意识的觉得某些问题是小问题，
	亦或我们需要为一些其他原因做出妥协。所以我们一直在面临一个选择题：你的代码是**`能用`**还是**`好用`**。
- **`Talk is cheap，show me the code`**。
	总结一下的话，主要有这样五点：
	应对面试中的设计模式相关问题；
	告别写被人吐槽的烂代码；
	提高复杂代码的设计和开发能力；
	让读源码、学框架事半功倍；
	为你的职场发展做铺垫；

### 什么是好代码
- 可维护性（maintainability）。
- 可读性（readability）。<br />
	代码被阅读的次数远远超过被编写和执行的次数。
	> “Any fool can write code that a computer can understand. Good programmers write code that humans can understand.”<br />
	> “任何傻瓜都会编写计算机能理解的代码。<br />好的程序员能够编写人能够理解的代码。”
- 可扩展性（extensibility）。
- 灵活性（flexibility）。
- 简洁性（simplicity）。
- 可复用性（reusability）。
- 可测试性（testability）。

### 设计原则
- SOLID 原则
	- SRP 单一职责原则
	- OCP 开闭原则
	- LSP 里式替换原则
	- ISP 接口隔离原则
	- DIP 依赖倒置原则
- KISS 原则
- DRY 原则
- 迪米特法则

### 设计模式
- 创建型
	- 常用的有：单例模式、工厂模式（工厂方法和抽象工厂）、建造者模式。
	- 不常用的有：原型模式。
- 结构型
	- 常用的有：代理模式、桥接模式、装饰者模式、适配器模式。
	- 不常用的有：门面模式、组合模式、享元模式。
- 行为型
	- 常用的有：观察者模式、模板模式、策略模式、职责链模式、迭代器模式、状态模式。
	- 不常用的有：访问者模式、备忘录模式、命令模式、解释器模式、中介模式。

### 面向对象对比面向过程的优点
- 大多数情况下，我们常写的面向过程的代码实际上是把业务翻译成了逻辑代码，当然这个过程中有提取公共部分，拆解为模块，
	但是模块化这个过程并非必须。而面向对象则是将业务映射为了类或对象，我们需要为业务建模，
	尤其是面对复杂的业务，多是类似于网状结构，面向对象的代码更易维护、复用和扩展。
- 面向对象的代码之所以代码更易维护、复用和扩展，是因为其本身的特性（封装、抽象、继承、多态）。
	例如可以从父类继承一个子类，在子类重写父类的功能，遵从了**“对修改关闭，对扩展开放”**
- 越抽象、越顶层、越脱离具体某一实现的设计，越能提高代码的灵活性，越能应对未来的需求变化。
	好的代码设计，不仅能应对当下的需求，而且在将来需求发生变化的时候，仍然能够在不破坏原有代码设计的情况下灵活应对。
	
### 几个姿势
- 基于接口而非实现。
	接口和实现相分离，封装不稳定的实现，暴露稳定的接口。
- 多用组合（而非继承）。
	需要对逻辑做更细粒度的拆分。
	
### 辩证思考与灵活应用
- 开发前再好的设计，也不可能把每个细节、交互都想得很清楚。
	在落实到代码的时候，我们还是要反复迭代、重构、打破重写。
- 开发是一个反复迭代、遇到问题解决问题的过程，是一个不断重构的过程。
	我们没法严格地按照顺序执行各个步骤。
	
### MV(?)
- 如何将数据展示到视图上，然后又如何将用户输入写入到数据中，
	不同的人产生不同的看法，就出现了很多种架构设计，目的都是为了解耦Model和View。
- 不管是MVVM还是其他的，大多是MVC演变而来（因为MVC本身还是有些问题，例如Controller承担的职责太重）。
- 为什么要分层？
	- 能起到代码复用的作用。
	- 能起到隔离变化的作用。
		例如View层只消费数据进行渲染，而不关心数据从哪个接口来。大多数情况下Model层的接口变动并不会影响到View层。
	- 能起到隔离关注点的作用。
		三层之间的关注点不同，分层之后，职责分明，更加符合单一职责原则，代码的内聚性更好。
	- 能应对系统的复杂性。
		当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。自然就会去拆分代码。
		拆分有垂直和水平两个方向。水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。
		
### 重构
- 重构的目的：为什么要重构（why）？
- 重构的对象：到底重构什么（what）？
- 重构的时机：什么时候重构（when）？
- 重构的方法：又该如何重构（how）？